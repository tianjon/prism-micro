# 平台架构——双用户模型

---

## TL;DR（高管速读版）

Prism 的架构做了一个不同寻常的押注：**系统的一等公民不只是人类用户，还有 AI Agent**。这不是"未来再加"的功能，而是地基级别的设计决策。

为什么这很重要？因为架构决策具有不可逆性——就像城市的下水道系统，建成后改造的成本是初始投资的 10 倍。我们选择在 Day 1 就把 Agent 作为内建用户类型，而不是等到 Day 100 再往上"贴"。

核心设计：
- **双用户模型**：Human Principal + Agent Principal，统一认证、统一授权、统一审计
- **微服务拓扑**：5 个核心服务 + 1 个共享库，通过严格的依赖方向约束保证系统可演化
- **数据架构三层分离**：PostgreSQL（真相源）+ pgvector（加速层）+ Redis（临时状态层）
- **Agent 运行时前置**：在 VOC 数据层之前就交付 Agent 基础设施，让"骨架"先于"肌肉"就位

这一章是连接业务愿景和技术实现的桥梁。非技术读者能看懂架构的"为什么"，技术读者能理解架构的"怎么做"。

---

## 1. 为什么架构设计是战略问题

### 1.1 Conway 定律：你画的架构图就是你公司的组织图

1967 年，Melvin Conway 提出了一个看似平淡却影响深远的观察：

> "设计系统的组织，其产出的系统架构必然映射该组织的沟通结构。"

翻译成大白话就是——**四个团队造浏览器，你一定会得到一个四引擎的浏览器**。这不是笑话，而是几乎所有大型软件项目都会踩的坑。

Conway 定律的逆命题同样成立：**如果你想要一个特定形状的系统，就必须先构建一个与之匹配的组织形状**。Prism 的架构设计，本质上是在回答一个组织问题：我们希望这个产品以什么方式演化？

我们的答案是：**人类和 AI Agent 并肩工作，各自发挥最大优势**。这意味着架构必须从一开始就为两类截然不同的"用户"提供平等的、原生的支持——而不是先造一个给人用的系统，再把 Agent "塞"进去。

### 1.2 架构决策的不可逆性与早期投资回报

软件架构中存在两类决策：

| 类型 | 特征 | 例子 | 改错成本 |
|------|------|------|---------|
| **Type 1（单向门）** | 做了就回不去 | 数据库 schema 设计、认证模型、服务边界 | 极高 |
| **Type 2（双向门）** | 做错了可以调 | UI 配色、API 参数命名、日志格式 | 低 |

Jeff Bezos 在亚马逊股东信中反复强调：要在 Type 1 决策上深思熟虑、在 Type 2 决策上快速迭代。

"系统是否原生支持 Agent 作为用户"是一个典型的 Type 1 决策。如果你在 v1 没有做这个设计，到 v3 想加——你需要改认证系统、改权限模型、改审计日志、改 API 协议、改数据库 schema。这不是"重构"，这是"重写"。

早期投入的回报率呈现幂律分布：**在 Day 1 做对架构决策，比 Day 100 修正架构问题，成本相差一到两个数量级**。这就是为什么我们在这一章用这么大的篇幅，把架构讲清楚。

---

## 2. 双用户模型：Human + Agent

### 2.1 What：系统的一等公民同时包括人类和 AI Agent

传统系统的用户模型很简单：**User = Human**。登录的是人，操作的是人，看报表的也是人。AI 如果存在，要么是后台的"黑盒模型"，要么是前台的"智能助手"——本质上是系统的一个"功能模块"，而不是一个"用户"。

Prism 的双用户模型重新定义了这个假设：

```
传统模型：  Human → System → Output
Prism 模型：Human ─┐
                   ├──→ System → Output
            Agent ─┘
```

在 Prism 中，Agent 不是挂在系统边缘的附件，而是与人类用户并列的一等公民（First-Class Citizen）。它有自己的身份、自己的权限、自己的配额，以及自己独立的审计追踪链路。

**这意味着什么？**

- Agent 可以独立调用系统 API，无需人类在旁边"按回车"
- Agent 的行为可以被独立监控、限制和审计
- 未来的 Agent 能力扩展不需要改动认证和授权的地基
- 人类和 Agent 可以在同一个工作流中协作，各取所长

### 2.2 Why：Agent 不是"加上去的功能"，而是"内建的用户类型"

让我用一个硬件行业的类比来说明为什么"内建"和"外加"有本质区别。

**类比：iPhone 的触摸屏 vs Windows 8 的触摸支持**

2007 年，苹果发布 iPhone 时，触摸是整个操作系统的核心交互模型。每一个 UI 元素、每一个手势、每一个动画，都是围绕"手指直接操控屏幕"来设计的。没有鼠标指针，没有右键菜单，没有下拉列表——因为这些概念在触摸语境下不存在。

2012 年，微软发布 Windows 8。它试图给一个为鼠标和键盘设计了 30 年的操作系统"加上"触摸支持。结果是什么？一个精神分裂的产品——触摸界面和桌面界面来回切换，用户两头都不满意。微软花了三年时间才在 Windows 10 中找到了妥协方案，而这个妥协方案至今仍有争议。

同样的道理：

| 路径 | 描述 | 结果 |
|------|------|------|
| **先为人设计，再加 Agent** | 在已有系统上包装 Agent API | Agent 能力受限，权限模型不匹配，审计有盲区 |
| **从第一天就为 Human + Agent 设计** | 统一的 Principal 抽象 | 两类用户都是一等公民，系统天然可被编排 |

Prism 选择了第二条路。

### 2.3 How：统一的 Principal 抽象

在具体实现上，Prism 引入了 **Principal** 这个统一抽象来屏蔽人类和 Agent 的差异。Principal 是一个数学意义上的"操作主体"——它有身份（identity）、有凭证（credential）、有能力（capability）、有边界（boundary）。

#### 认证层：JWT + API Key，殊途同归

```
┌─────────────────────────────────────────────────┐
│                  统一身份层                       │
│                                                 │
│   Human Principal          Agent Principal      │
│   ┌───────────────┐       ┌───────────────┐    │
│   │ 认证: JWT      │       │ 认证: API Key  │    │
│   │ 来源: 登录流程  │       │ 来源: 密钥签发  │    │
│   │ 生命周期: 短    │       │ 生命周期: 长    │    │
│   │ 刷新: Refresh  │       │ 刷新: 轮换     │    │
│   │   Token       │       │               │    │
│   └───────┬───────┘       └───────┬───────┘    │
│           │                       │             │
│           └───────────┬───────────┘             │
│                       ▼                         │
│              ┌─────────────────┐                │
│              │  Principal 身份  │                │
│              │  ─────────────  │                │
│              │  id: UUID       │                │
│              │  type: human    │                │
│              │    | agent      │                │
│              │  roles: [...]   │                │
│              │  capabilities:  │                │
│              │    [...]        │                │
│              └─────────────────┘                │
└─────────────────────────────────────────────────┘
```

人类通过浏览器登录，获取 JWT Token；Agent 通过 API Key 认证，获取长期凭证。两条路径在认证之后汇入同一个 Principal 对象——下游的所有服务只认 Principal，不关心它的原始凭证类型。

这就像机场安检：无论你拿的是中国护照还是美国护照，通过安检后你得到的是同一种"已验证旅客"身份。航空公司不需要知道你的护照是什么颜色的——它只关心你是否通过了安检。

#### 授权层：角色 + 能力的权限模型

传统的 RBAC（基于角色的访问控制）对 Agent 来说不够用。一个 Agent 可能有"分析师"角色，但你不希望它能删除数据。所以 Prism 采用 **Role + Capability** 的混合模型：

| 维度 | 说明 | 例子 |
|------|------|------|
| **角色（Role）** | 粗粒度权限集合 | admin, analyst, viewer |
| **能力（Capability）** | 细粒度操作许可 | llm:chat, voc:search, voc:write, agent:execute |
| **约束（Constraint）** | 运行时限制 | 每分钟最大调用次数、单次最大 token 数、成本上限 |

Agent 的权限通常比同角色的人类更窄、约束更紧。这遵循最小权限原则（Principle of Least Privilege）：给 Agent 刚好够完成任务的权限，不多给一丝一毫。

#### 审计层：所有操作统一审计，区分操作者身份

每一次 API 调用都生成审计日志，记录三个关键信息：

1. **Who**：哪个 Principal 发起了操作（人类还是 Agent？具体是谁？）
2. **What**：做了什么操作（调用了哪个 API？传了什么参数？）
3. **When & Where**：什么时间、从哪里发起的

这不仅是合规要求，更是建立信任的基础。当 CEO 问"这个分析结论是 AI 自己跑出来的，还是分析师跑出来的？"——审计日志能给出精确答案。

### 2.4 Risk：看见风险才能管理风险

双用户模型不是没有风险。诚实地看待这些风险，是做出好决策的前提。

| 风险 | 描述 | 缓解策略 |
|------|------|---------|
| **权限过大** | Agent 获得了超出其任务范围的权限 | 最小权限原则 + 能力白名单 + 每次任务独立授权 |
| **行为不可预测** | LLM 驱动的 Agent 可能做出非预期操作 | 关键操作需人类确认（Human-in-the-Loop）+ 操作沙箱 |
| **成本失控** | Agent 自主调用 LLM，可能消耗大量 token | 单任务成本上限 + 实时成本追踪 + 自动熔断 |
| **审计复杂度** | 人机混合操作链路难以追踪 | 统一审计格式 + 操作链 trace ID + 可视化追溯 |

每一项风险都有对应的架构级缓解措施。这些不是"后面再想"的事情，而是"现在就设计进去"的事情。

### 2.5 Benefit：从 Day 1 就具备被编排的能力

当双用户模型就位后，系统获得了几个传统 VOC 平台完全不具备的能力：

1. **Agent 自主分析**：Agent 可以在凌晨 3 点自动跑完"本周新涌现问题"的探索分析，第二天早上产品经理打开邮箱就有结论
2. **人机协作工作流**：Agent 做初步筛选和聚类，人类做最终判断和决策——各取所长
3. **渐进式自动化**：从"人做、Agent 辅助"到"Agent 做、人审核"到"Agent 自主、人监控"，系统支持平滑过渡
4. **API 生态就绪**：外部系统的 Agent 也可以通过 API Key 接入 Prism，平台具备生态潜力

这就是"内建"和"外加"的本质区别：**内建的能力可以渐进释放，外加的功能永远在追赶**。

---

## 3. 微服务拓扑

### 3.1 服务边界图

Prism 采用 Monorepo + 微服务架构，所有代码在同一仓库中，通过 uv workspace 管理 Python 包依赖。当前的服务拓扑如下：

```
                      ┌─────────────┐   ┌─────────────┐
                      │   Web UI    │   │    CLI      │
                      │ (apps/web)  │   │ (apps/cli)  │
                      │ React+Vite  │   │   Typer     │
                      └──────┬──────┘   └──────┬──────┘
                             │                  │
                             │     HTTP REST    │
                      ┌──────┴──────────────────┴──────┐
                      │                                │
               ┌──────▼──────┐              ┌──────────▼─────┐
               │ user-service │              │  llm-service   │
               │  (认证服务)   │              │ (LLM 统一网关)  │
               │ /api/auth/* │              │  /api/llm/*    │
               └──────┬──────┘              └───────┬────────┘
                      │                             │
                      │   Python import             │
                      └────────────┬────────────────┘
                                   │
                            ┌──────▼──────┐
                            │   shared    │
                            │  (共享库)    │
                            │ DB Session  │
                            │ JWT 工具    │
                            │ 认证中间件   │
                            └──────┬──────┘
                                   │
                    ┌──────────────┬┴──────────────┐
                    │              │               │
              ┌─────▼─────┐ ┌─────▼─────┐  ┌──────▼──────┐
              │ PostgreSQL │ │   Redis   │  │  外部 LLM   │
              │ (数据存储)  │ │  (缓存)   │  │  Provider   │
              │ llm|auth   │ │           │  │  (API 调用)  │
              │  schema    │ │           │  │             │
              └───────────┘ └───────────┘  └─────────────┘
```

### 3.2 各服务职责一览

| 服务 | 路径 | 技术栈 | 核心职责 |
|------|------|--------|---------|
| **shared** | `shared/` | Python 库 | DB 连接、JWT 工具、认证中间件、通用模型——"工具箱" |
| **user-service** | `user-service/` | FastAPI | 用户注册/登录、JWT 签发/刷新、API Key 管理 |
| **llm-service** | `llm-service/` | FastAPI | 多 Provider 管理、模型别名系统、故障转移、统一 Chat/Embedding/Rerank API |
| **Web UI** | `apps/web/` | React + Vite | 用户登录界面、模型配置管理、未来的分析交互界面 |
| **CLI** | `apps/cli/` | Typer | 命令行工具，同时作为 AI Agent 的标准化工具接口 |

### 3.3 依赖方向——不可逆约束

依赖方向是架构中最重要的"交通规则"。打个比方：这就像城市的单行道——一旦画好就不能随意改，否则全城堵车。

**三条铁律**：

1. **shared 不依赖任何上层服务**——它是地基，地基不能依赖楼层
2. **llm-service 和 user-service 互不依赖**——它们是平行的楼层，各管各的
3. **前端和 CLI 只通过 HTTP 调用后端**——它们是住户，通过电梯（API）进出大楼，不能在楼里打洞

违反这三条规则中的任何一条，都会导致系统耦合度急剧上升，最终变成一个看似多服务、实则是单体的"分布式单体"——这是微服务架构中最糟糕的反模式。

### 3.4 Schema 隔离策略

所有服务共享一个 PostgreSQL 实例（`prism` 数据库），通过 PostgreSQL 的 schema 机制实现逻辑隔离：

| Schema | 所属服务 | 数据内容 |
|--------|---------|---------|
| `auth` | user-service | 用户表、API Key 表 |
| `llm` | llm-service | Provider 配置、模型定义、别名映射 |
| `voc` | voice-service（Phase 3） | VOC 原始数据、语义片段、标签 |
| `agent` | agent-runtime（Phase 2.5） | Skill 注册、执行记录、上下文 |

Schema 隔离是一个精心选择的"中间路线"。对比三种常见策略：

| 策略 | 隔离度 | 运维成本 | 适用场景 |
|------|--------|---------|---------|
| 共享表 | 低 | 最低 | 原型阶段 |
| **Schema 隔离**（Prism 选择） | 中 | 低 | 早期到中期 |
| 独立数据库实例 | 高 | 高 | 大规模生产环境 |

Schema 隔离的核心优势在于**低成本可逆性**：如果未来某个服务的数据量暴增或需要独立扩展，只需要把对应 schema 的数据迁移到独立实例——不需要改代码，只需要改连接字符串。

---

## 4. Agent 基础运行时（Phase 2.5）

### 4.1 为什么在 VOC 数据层之前交付 Agent 运行时

这是一个反直觉的决策，值得用充足的篇幅解释。

常规思路是："先有数据（Phase 3 的 VOC 数据摄入），再有分析工具（Agent），最后让 Agent 去分析数据。"这就像先盖好房子，再请室内设计师。

Prism 的思路是："先搭好 Agent 的骨架（Phase 2.5），让它能跑起来，哪怕一开始只有很少的工具可用。等 VOC 数据层就位（Phase 3），Agent 立刻就能接入新能力。"这就像先请室内设计师参与建筑设计，确保房间的布局、电路、水管都为未来的使用方式做好准备。

用软件工程的术语来说：**Agent 运行时是"骨架"，VOC 数据是"肌肉"。先有骨架，肌肉才能长对地方。**

具体的好处包括：

1. **提前验证 Agent Loop 的可行性**：在数据量小的时候就能发现架构问题，修复成本极低
2. **Skill 注册机制可以立即被 llm-service 使用**：Phase 2.5 交付后，Agent 就能调用 LLM 能力
3. **双身份认证可以提前投入生产**：不用等 VOC 数据就绪才开始考虑 Agent 的安全问题
4. **团队可以并行开发**：Agent 团队和 VOC 数据团队可以各自推进，通过接口合约对齐

### 4.2 Skill 注册表：声明式工具定义

Agent 的能力来源于 **Skill**（技能）。每个 Skill 是一个声明式定义的原子工具，Agent 通过组合多个 Skill 来完成复杂任务。

Skill 的设计哲学是：**Agent 不需要知道工具是怎么实现的，只需要知道工具能做什么、需要什么输入、会给出什么输出。**

这就像你用手机叫外卖——你不需要知道骑手的路线规划算法，你只需要知道：输入一个地址和一个菜单，输出一份送到门口的饭。

一个典型的 Skill 声明包含：

| 字段 | 说明 | 例子 |
|------|------|------|
| name | 工具名称 | `llm_chat` |
| description | 自然语言描述（给 LLM 看） | "与大语言模型进行对话" |
| parameters | 输入参数 schema | `{ model: string, messages: Message[] }` |
| returns | 输出 schema | `{ content: string, usage: TokenUsage }` |
| requires | 所需能力（权限） | `["llm:chat"]` |
| cost_estimate | 预估成本 | `0.01 USD / 调用` |

Skill 注册表是一个中心化的"工具目录"。Agent 在运行时查询注册表，了解自己有哪些工具可用，然后根据任务需求选择合适的工具组合。

### 4.3 Agent Loop：推理-行动循环

Agent 的核心运行机制是一个 **ReAct（Reasoning + Acting）循环**，这是当前 AI Agent 领域最成熟的架构模式：

```
┌──────────────────────────────────────────────────┐
│                  Agent Loop                       │
│                                                  │
│   ┌──────────┐    ┌──────────┐    ┌──────────┐  │
│   │  推理     │───▶│  工具调用  │───▶│ 结果整合  │  │
│   │ Reasoning│    │  Action  │    │ Integrate│  │
│   └──────────┘    └──────────┘    └──────────┘  │
│        ▲                                │        │
│        │                                ▼        │
│        │          ┌──────────┐                   │
│        └──────────│ 继续/终止  │                   │
│                   │ Decision │                   │
│                   └──────────┘                   │
│                                                  │
│   每一轮循环消耗: LLM tokens + 工具调用 + 时间       │
│   终止条件: 任务完成 | 达到迭代上限 | 成本达到上限     │
└──────────────────────────────────────────────────┘
```

每一轮循环的四个步骤：

1. **推理（Reasoning）**：Agent 基于当前上下文（任务目标 + 已有信息 + 历史操作），决定下一步应该做什么
2. **工具调用（Action）**：Agent 从 Skill 注册表中选择合适的工具，传入参数，执行调用
3. **结果整合（Integrate）**：将工具返回的结果纳入上下文，更新对任务的理解
4. **继续/终止（Decision）**：判断任务是否完成，或是否需要继续探索

这个循环的精妙之处在于：**每一步的决策都是 LLM 做出的，但每一步的执行都是受约束的**。Agent 不能直接操作数据库，只能通过已注册的 Skill；不能超出自己的权限范围；不能消耗超出上限的资源。

### 4.4 执行上下文：权限、配额与成本追踪

每次 Agent 执行任务时，系统会为其创建一个独立的**执行上下文（Execution Context）**，包含三个核心维度：

```
执行上下文 (Execution Context)
├── 权限边界
│   ├── Principal 身份 (Agent 的 API Key 对应的身份)
│   ├── 可用 Skill 列表 (基于 capabilities 过滤)
│   └── 数据访问范围 (基于角色和约束)
│
├── 资源配额
│   ├── 最大迭代次数 (e.g. 20 轮)
│   ├── 最大 LLM token 消耗 (e.g. 50,000 tokens)
│   ├── 最大执行时间 (e.g. 5 分钟)
│   └── 最大成本 (e.g. 0.50 USD)
│
└── 追踪信息
    ├── trace_id (全链路追踪 ID)
    ├── 操作日志 (每一步的输入/输出)
    ├── 成本累计 (实时更新)
    └── 触发者 (哪个人类用户或系统触发了这次执行)
```

执行上下文的设计思路借鉴了操作系统的"进程"概念：每个 Agent 任务运行在自己的"进程"里，有自己的资源限额，不会影响其他任务，任何一步出错都可以安全终止。

---

## 5. 数据架构哲学

### 5.1 Truth vs Acceleration 分层

Prism 的数据架构遵循一个核心原则：**区分"真相"和"加速"**。

这个原则的灵感来自于信息科学中的 DIKW 金字塔（Data → Information → Knowledge → Wisdom），但我们做了一个工程化的简化：数据存储只分两层——**不可变的真相**和**可重建的加速器**。

用图书馆打比方：

- **真相层**是图书馆的藏书——每一本书都是原始的、完整的、不可替代的
- **加速层**是图书馆的目录卡片和索引——丢了可以重建，但有了它们找书快 100 倍
- **临时状态层**是图书馆门口的"今日推荐"白板——写了擦、擦了写，丢了也无所谓

### 5.2 三层存储架构

```
┌──────────────────────────────────────────────┐
│          PostgreSQL — 不可变真相源             │
│                                              │
│   auth schema: 用户、API Key                 │
│   llm schema:  Provider 配置、模型、别名       │
│   voc schema:  原始 Voice、语义片段、标签       │
│   agent schema: Skill 定义、执行记录           │
│                                              │
│   特性: ACID 事务、强一致性、Alembic 迁移管理   │
│   原则: 所有业务数据的 Single Source of Truth   │
└──────────────────────────────────────────────┘
                      │
                      │ 数据同步/索引
                      ▼
┌──────────────────────────────────────────────┐
│          pgvector — 可重建加速层               │
│                                              │
│   向量索引: 语义片段的 embedding 向量           │
│   用途: 语义搜索、近邻查询、聚类分析             │
│                                              │
│   特性: 可从原始数据重建、支持 HNSW/IVFFlat    │
│   原则: 丢失后可重新生成，不存储不可恢复的数据    │
└──────────────────────────────────────────────┘
                      │
                      │ 热数据缓存
                      ▼
┌──────────────────────────────────────────────┐
│            Redis — 临时状态层                  │
│                                              │
│   llm:*  Provider 健康状态、调用频率限制        │
│   auth:* Token 黑名单、Session 缓存           │
│   agent:* 执行上下文快照                      │
│                                              │
│   特性: 高速读写、自动过期、Key 前缀隔离        │
│   原则: 全部丢失不影响业务正确性，只影响性能      │
└──────────────────────────────────────────────┘
```

这种分层设计带来一个极其重要的运维优势：**灾难恢复的优先级非常清晰**。

| 存储层 | 丢失后果 | 恢复方式 | 恢复时间 |
|--------|---------|---------|---------|
| PostgreSQL | 数据丢失，业务中断 | 从备份恢复 | 小时级 |
| pgvector 索引 | 语义搜索不可用，其他功能正常 | 从原始数据重建 | 分钟到小时级 |
| Redis | 性能下降，需要重新登录 | 自动恢复（重新缓存） | 秒级 |

**当一切都可能出错时，你需要知道什么绝对不能丢。**

---

## 6. 远景架构图

下面是 Prism 完整的远景架构，涵盖从 Phase 1 到 Phase 6 的所有层次：

```
╔══════════════════════════════════════════════════════════════════╗
║                        用 户 层                                  ║
║                                                                ║
║    ┌────────────────────┐         ┌────────────────────┐       ║
║    │      Web UI        │         │       CLI          │       ║
║    │    (React+Vite)    │         │     (Typer)        │       ║
║    │                    │         │                    │       ║
║    │  - 分析工作台       │         │  - prism chat      │       ║
║    │  - 概念治理界面     │         │  - prism analyze   │       ║
║    │  - Agent 监控面板   │         │  - Agent 工具接口   │       ║
║    └────────┬───────────┘         └────────┬───────────┘       ║
║             │                              │                   ║
╠═════════════╪══════════════════════════════╪═══════════════════╣
║             │    Agent 引 擎 层             │                   ║
║             │                              │                   ║
║    ┌────────▼──────────────────────────────▼───────────┐       ║
║    │              Agent Runtime Service                │       ║
║    │                                                   │       ║
║    │  ┌────────────┐  ┌────────────┐  ┌────────────┐  │       ║
║    │  │ Skill 注册  │  │ Agent Loop │  │ 上下文管理  │  │       ║
║    │  │   表       │  │  推理-行动  │  │  权限/配额  │  │       ║
║    │  │            │  │   循环     │  │  /成本     │  │       ║
║    │  └────────────┘  └────────────┘  └────────────┘  │       ║
║    │                                                   │       ║
║    │  ┌────────────────────────────────────────────┐   │       ║
║    │  │          工作流编排 (Phase 5)               │   │       ║
║    │  │  多 Agent 协作 · 自定义 Skill · DAG 编排    │   │       ║
║    │  └────────────────────────────────────────────┘   │       ║
║    └───────────┬───────────────┬───────────┬──────────┘       ║
║                │               │           │                   ║
╠════════════════╪═══════════════╪═══════════╪══════════════════╣
║                │   服 务 层     │           │                   ║
║                │               │           │                   ║
║       ┌────────▼────────┐ ┌───▼────────┐ ┌▼──────────────┐   ║
║       │   LLM Gateway   │ │ VOC Data   │ │  内置工具      │   ║
║       │   (llm-service) │ │  Service   │ │  (Built-in    │   ║
║       │                 │ │ (Phase 3)  │ │   Skills)     │   ║
║       │  - Chat         │ │            │ │               │   ║
║       │  - Embedding    │ │ - 数据摄入  │ │ - 统计分析    │   ║
║       │  - Rerank       │ │ - 语义拆分  │ │ - 可视化      │   ║
║       │  - 别名/故障转移 │ │ - 向量检索  │ │ - 报告生成    │   ║
║       │                 │ │ - 概念治理  │ │ - 导出        │   ║
║       └────────┬────────┘ └─────┬──────┘ └───────────────┘   ║
║                │                │                              ║
║       ┌────────▼────────┐      │                              ║
║       │  user-service   │      │                              ║
║       │   (认证服务)     │      │                              ║
║       │                 │      │                              ║
║       │  - JWT/API Key  │      │                              ║
║       │  - Principal    │      │                              ║
║       │    管理         │      │                              ║
║       └────────┬────────┘      │                              ║
║                │               │                              ║
╠════════════════╪═══════════════╪═════════════════════════════╣
║                │   数 据 层     │                              ║
║                │               │                              ║
║    ┌───────────▼───────────────▼──────────────────────┐       ║
║    │              PostgreSQL 17 + pgvector             │       ║
║    │                                                   │       ║
║    │  auth schema │ llm schema │ voc schema │ agent   │       ║
║    │  用户/密钥    │ 模型/别名   │ 语义/标签   │ 技能/记录│       ║
║    │                                                   │       ║
║    │  ──────── pgvector 向量索引 (可重建) ────────      │       ║
║    └───────────────────────────────────────────────────┘       ║
║                                                                ║
║    ┌───────────────────────────────────────────────────┐       ║
║    │                    Redis 7                        │       ║
║    │  llm:* 健康/限流 │ auth:* 会话 │ agent:* 上下文   │       ║
║    └───────────────────────────────────────────────────┘       ║
║                                                                ║
╚══════════════════════════════════════════════════════════════════╝
```

### 各层的设计原则

| 层级 | 设计原则 | 关键约束 |
|------|---------|---------|
| **用户层** | 展示与交互，不含业务逻辑 | 只通过 HTTP 调用服务层 |
| **Agent 引擎层** | 编排与推理，不直接存取数据 | 通过 Skill 调用服务层 |
| **服务层** | 业务逻辑封装，各服务独立 | 服务间不直接依赖 |
| **数据层** | 持久化与查询，不含业务逻辑 | 通过 shared 库访问 |

每一层都遵循同一条准则：**只依赖下层，不依赖上层和同层**。这是分层架构（Layered Architecture）的基本纪律，违反它会导致系统变成一团意大利面——看起来一盘菜，实际上拉一根抽出三根。

### 从 Phase 1 到 Phase 6 的渐进演化

```
Phase 1  基础设施 ─────────▶ 微服务骨架就位
Phase 2  LLM 调用 ─────────▶ llm-service 可用
Phase 2.5 Agent 运行时 ────▶ Agent 引擎层就位（骨架）
Phase 3  VOC 数据 ─────────▶ 数据层充实（肌肉）
Phase 4  概念治理 ─────────▶ 人机共治能力就位
Phase 5  Agent 高级编排 ───▶ Agent 引擎层成熟（多 Agent 协作）
Phase 6  洞察引擎 ─────────▶ 平台化，开放生态
```

每个阶段独立可交付、可演示，并设有 Go/No-Go 评审点。后一个阶段的启动以前一个阶段的验收通过为前提。这确保了投资风险的可控性——在任何一个阶段，管理层都可以基于当前结果决定是继续投入、调整方向还是止损退出。

---

## Key Takeaways

1. **架构决策是战略决策**。Conway 定律告诉我们，系统结构映射组织结构。决定"Agent 是一等公民"不只是技术选择，更是对产品形态的战略押注。

2. **双用户模型是 Prism 最核心的架构创新**。统一的 Principal 抽象让人类和 Agent 通过不同凭证进入同一个身份体系，享有统一的授权和审计。这不是"未来再加"的功能，而是 Day 1 的地基。

3. **内建 vs 外加是天壤之别**。就像 iPhone 的触摸屏 vs Windows 8 的触摸支持——架构层面的"内建"让能力可以渐进释放，而"外加"永远在追赶。

4. **微服务拓扑有严格的依赖方向约束**。shared 不依赖上层、平行服务互不依赖、前端只通过 HTTP 调用后端——这三条铁律保证系统可演化而不退化为分布式单体。

5. **Agent 运行时前置于数据层交付（Phase 2.5 先于 Phase 3）**。骨架先于肌肉——这确保后续的 VOC 数据能力一上线就能被 Agent 编排使用，而不是先建好数据仓库再去想怎么用。

6. **数据架构三层分离：Truth / Acceleration / Ephemeral**。PostgreSQL 存真相、pgvector 做加速、Redis 管临时状态。灾难恢复优先级清晰，运维心智负担最小化。

7. **每个阶段独立可交付，风险可控**。六阶段路线图中的每一步都设有评审点，管理层始终保有决策主动权。

---

*本章是业务愿景与技术实现之间的桥梁。下一章（Ch04 核心能力深度剖析）将深入展开 Prism 的五大能力群如何在这一架构之上协同工作——从语义理解引擎到用户体验层，逐一剖析每个能力的 What/Why/How/Risk/Benefit。*
