# D1-C：工作流与协作 — 聚焦辩论记录

> 议题组 C 围绕 Git 分支策略、设计文档同步、代码审查标准三个子议题展开深入辩论。核心张力在于"流程严格性"与"迭代速度"之间的平衡点。

**日期**：开发启动前
**主持人**：赵一凡（技术负责人）
**参会人**：全体 6 人
**依据**：D0 立场宣言 T4 节各人观点

---

## 子议题 C1：Git 分支策略

### 开场陈述

**赵一凡**（主张：主干开发 + 功能开关）：

> 我直接亮底牌。6 个人的团队如果搞多长期分支，一周之内就会遇到合并冲突。我在上一个项目见过最痛的教训——三个人各自在功能分支上开发了两周，合并那天改了 400 多个冲突，整整浪费了两天。
>
> 主干开发的核心思路是：`main` 是唯一的长期分支，所有人从 main 拉短命分支，两天之内合回来。功能没做完怎么办？用功能开关。比如 `FEATURE_VOC_IMPORT=false`，代码在 main 上，但运行时不生效。这样 main 永远是可部署的，集成问题在最早的时间被发现。
>
> 我建议的具体规则：功能分支命名 `feat/<issue-id>-<description>`，生命周期不超过 2 个工作日。如果 2 天合不回来，说明任务拆分有问题，需要回头拆更细。

**王磊**（主张：GitHub Flow，反对功能开关）：

> 一凡，你的道理我都懂，但功能开关的维护成本你算过没有？你在代码里加一堆 `if FEATURE_XXX`，这些开关本身就是技术债。谁来记得删？删的时候谁来确认没有遗留分支？
>
> GitHub Flow 就够了。`main` + 功能分支，分支名清晰，PR 合并后删除。区别在于我不要求两天合回来——有些功能就是需要三四天，比如批量导入的完整链路。硬卡两天只会逼开发者提半成品的 PR，审查的人看不懂，合并进去也没人敢用。
>
> 我们 6 个人，核心代码路径交叉不多——llm-service、voc-service、前端基本独立开发。真正有冲突的就是 shared 库，但 shared 改动本来就应该小而频繁。不需要为了解决一个不太存在的问题引入功能开关这个新复杂度。

**周安**（主张：main 分支保护 + 强制 PR 审查）：

> 不管你们选哪个方案，有一点是不能商量的：`main` 必须开启分支保护规则。直接 push 到 main 这种事绝对不能发生。
>
> 具体要求：所有合入 main 的代码必须通过 PR，至少 1 个 Approval，CI 全绿。这不是流程负担，这是工程底线。我见过太多"临时 push 到 main 修个小 bug"然后搞挂全量服务的案例。
>
> 另外，关于分支命名，我建议加上类型前缀和 Issue 编号，跟 Conventional Commits 对齐：`feat/123-import-csv`、`fix/456-jwt-expiry`、`refactor/789-shared-db-session`。这样从分支名就能追溯到任务。

### 交锋辩论

**赵一凡**（回应王磊）：

> 王磊，你说功能开关是技术债，这个我同意。但长期分支是更大的技术债——它是隐性的，你看不见冲突积累了多少，直到合并那天才爆炸。功能开关至少是显式的、可搜索的、有明确移除时间的。
>
> 关于你说"有些功能需要三四天"——我的观点不是说三四天不能做，而是说三四天的功能应该拆成两到三个 PR。批量导入的完整链路可以拆成：第一个 PR 实现 CSV 解析和数据校验，第二个 PR 实现入库和去重，第三个 PR 接上 API 端点。每个 PR 独立可审查、独立可测试。
>
> 至于功能开关的清理，我建议用一个简单规则：功能开关在创建时必须在 Issue 中记录预计移除日期。超期未移除的，CI 直接告警。

**王磊**（反驳）：

> 你把批量导入拆成三个 PR，第一个 PR 合进去的时候，CSV 解析和数据校验的代码在 main 上跑着但没有 API 端点调用它。这不就是变相的功能开关吗？只不过你没用环境变量控制，而是靠"没人调用"来隐藏。
>
> 而且拆 PR 是有成本的。每个 PR 都要写描述、等审查、处理 CI。三个 PR 意味着三倍的流程开销。对于一个功能内聚的变更，一个完整的 PR 反而更容易审查——审查者能看到完整的上下文。
>
> 我的建议是折中：分支生命周期建议 3 天，不硬卡 2 天。超过 5 天的必须向技术负责人说明原因。不引入功能开关，但要求分支每天 rebase main 一次，降低合并冲突风险。

**陈思琪**（从 AI 工程角度切入）：

> 我想补充一个 Prompt 开发的实际场景。Prompt 模板的调优经常需要反复试验——改一个词、跑一批样本、看结果、再改。这种工作天然不适合两天的分支限制，也不适合拆成多个 PR。因为 Prompt 的每次改动都是完整的"假设-验证"循环。
>
> 但 Prompt 文件（`.jinja2` 模板）跟其他代码几乎没有冲突——它是独立文件，不存在合并冲突问题。所以对于 Prompt 开发分支，我建议放宽到 5 天，但要求每天 push 到远端（防止本地丢失），合并时必须附带测试结果。

**张晨曦**（前端视角）：

> 前端的情况又不一样。React 组件开发经常涉及多个文件的协调改动——页面、组件、hooks、API 层、类型定义，这些改动如果拆开来审查反而看不出整体设计。
>
> 但我支持短命分支的大方向。前端代码跟后端几乎没有文件级冲突，主要冲突点是 API 类型定义。只要后端的 OpenAPI Schema 稳定，前端分支可以独立开发。
>
> 我的建议：前端分支生命周期不超过 3 天，每个 PR 对应一个完整的用户故事（不拆到半个页面）。

**李维**（数据工程视角）：

> 爬虫和数据管线的开发有一个特殊性：它依赖外部数据源的行为。比如我在开发懂车帝爬虫的时候，可能需要反复调试反爬策略，这个过程很难预估时间。
>
> 但我同意分支不应该太长。我的建议是：数据管线的开发按步骤拆分——解析器一个 PR、清洗器一个 PR、入库器一个 PR。爬虫因为依赖外部环境，允许分支稍长但不超过 5 天。

**周安**（总结安全关切）：

> 关于功能开关，我有一个安全层面的关切。如果功能开关是通过环境变量控制的，那么生产环境的环境变量配置就变成了一个准代码发布渠道——谁改了环境变量就等于谁发布了新功能。这需要对环境变量变更做审计。
>
> 不过如果团队决定用功能开关，我可以在 CI 里加一个检查：扫描所有 `FEATURE_*` 开头的环境变量引用，确保每个都有对应的 Issue 和移除日期。

### C1 决议

**分支策略：改良版 GitHub Flow + 短命分支（不引入功能开关）**

| 规则 | 具体约定 |
|------|---------|
| 长期分支 | 仅 `main`，开启分支保护（禁止直推、要求 1 Approval、CI 全绿） |
| 功能分支命名 | `<type>/<issue-id>-<description>`，type 对齐 Conventional Commits |
| 分支生命周期 | **建议** 3 个工作日以内，**硬限** 5 个工作日。超 5 天需技术负责人批准并说明原因 |
| 每日 rebase | 生命周期 > 1 天的分支，每天至少 rebase main 一次（或 merge main），保持同步 |
| PR 拆分 | 超过 300 行的变更建议拆分。一个 PR 对应一个完整的逻辑单元（不强制拆到两天粒度） |
| 功能开关 | 暂不引入。如后续确有需要（如 A/B 测试、灰度发布），由技术负责人提议并设计统一方案 |
| Prompt 分支 | Prompt 模板变更允许独立分支，生命周期最长 5 天，合并时附带测试结果 |

**否决理由（功能开关）**：6 人团队的冲突概率低，功能开关的引入成本（代码分支复杂度 + 清理负担 + 环境变量审计）高于其收益。保留未来引入的可能性，但当前阶段不作为标准实践。

**否决理由（2 天硬限）**：过于激进的时间限制会导致 PR 拆分过细，增加流程开销，降低审查者对变更完整性的理解。3 天建议 + 5 天硬限是在频繁集成与开发效率间的平衡点。

---

## 子议题 C2：设计文档与代码同步

### 开场陈述

**赵一凡**（主张：重要变更先提 Design Doc PR）：

> 我的观点很明确：写代码之前先想清楚。对于重要变更——新 API 端点、新数据模型、架构层面的调整——必须先提一个 Design Doc PR。这个 PR 不包含代码，只包含设计文档，至少 2 人审查通过后才开始编码。
>
> 具体来说，我定义"重要变更"为以下任一条件：（1）新增或修改 API 端点；（2）新增或修改数据库表/Schema；（3）引入新的第三方依赖；（4）修改服务间通信方式；（5）修改 shared 库的公共接口。
>
> 设计文档不需要长篇大论。一页纸就够：**问题是什么、方案是什么、接口长什么样、有什么替代方案被否决了**。关键是让团队在写代码之前就达成共识，避免"代码写完了才发现方向不对"的浪费。

**王磊**（主张：代码即文档，设计文档容易过时）：

> 一凡，你说的那些设计文档，我在之前的项目里见过太多下场了——写的时候花了两小时，三周之后实现跟文档对不上了，然后就再也没人更新，变成误导性文档，比没有文档更害人。
>
> 我的观点是：代码才是最准确的文档。好的代码结构 + 清晰的类型注解 + 合理的变量命名 = 自文档化。如果你的代码需要一份额外的文档来解释它在做什么，说明代码本身不够清晰。
>
> 我不是说完全不要设计文档。真正需要设计文档的场景很少——架构级别的决策（比如"为什么选 LiteLLM 而不是自建适配器"）确实需要记录。但 API 端点设计？FastAPI 自动生成 OpenAPI Spec 就是最好的文档。数据模型设计？SQLAlchemy 模型定义本身就是可执行的文档。

**陈思琪**（主张：Prompt 变更需独立审查流程）：

> 我同意王磊说的普通代码的情况，但 Prompt 是个例外。Prompt 模板的改动影响范围远大于代码改动——一个词的调整可能让全量 AI 输出发生质的变化。而且 Prompt 的"正确性"不能通过类型检查或编译发现，只能通过实际运行样本数据来验证。
>
> 所以我提议：Prompt 变更必须作为独立 PR，PR 描述中包含三部分：（1）变更原因——为什么要改这个 Prompt；（2）预期影响评估——影响哪些管线阶段、涉及多少现有数据；（3）测试结果——至少 5 条样本数据的前后对比输出。
>
> 这不是设计文档，而是变更附带的验证证据。审查者可以根据这些信息判断变更是否安全。

**张晨曦**（主张：API 契约文档必须与代码同步更新）：

> 我不关心你们写不写设计文档，但有一类文档是绝对不能过时的：**API 契约**。前端基于 OpenAPI Schema 生成 TypeScript 类型，如果 Schema 跟实际 API 行为不一致，前端就会出运行时错误——而且是那种 TypeScript 编译器检查不出来、到生产环境才崩的错误。
>
> 我的要求很具体：后端 API 变更的 PR 必须同时更新 OpenAPI Schema（FastAPI 自动生成的也算，但必须确保自动生成的结果是正确的）。如果 API 返回的字段跟 Schema 定义不一致，前端有权 block 这个 PR。
>
> 另外，每次 API 变更后，后端应该通知前端组——不是说开个会，而是在 PR 中 @mention 前端组成员。让我们评估前端的适配工作量。

**李维**（数据工程视角）：

> 我补充一个数据管线的文档需求。数据导入的 Schema 映射规则——哪个 CSV 列对应哪个数据库字段、什么编码会被自动转换、什么格式的日期会被识别——这些如果不文档化，只有写代码的人知道。新来一个人维护导入功能，面对用户的"为什么我的 Excel 导入失败了"，他完全不知道从哪查起。
>
> 这类文档我建议写在代码旁边——不是独立的设计文档，而是模块级别的 docstring 或 README。比如 `voc-service/src/voc_service/import/README.md` 描述导入管线的处理规则。这样文档跟代码在同一个目录下，改代码的人更容易想起来更新文档。

### 交锋辩论

**赵一凡**（回应王磊）：

> 王磊，你说"代码是最好的文档"，这在战术层面我同意。但在战略层面不成立。代码告诉你 how，不告诉你 why。为什么选这个数据模型而不是另一个？为什么这个 API 是 POST 而不是 GET？为什么用异步而不是同步？这些决策的理由在代码里找不到。
>
> 而且设计文档过时的问题是管理问题，不是文档本身的问题。如果我们规定"修改代码时必须同时更新相关设计文档"，并且在 PR 模板里加一个 checklist 项"[ ] 已更新相关设计文档"，过时的概率会大幅降低。
>
> 不过我承认——不是所有变更都需要设计文档。一个 bug fix、一个小功能、一个重构，直接写代码 PR 就行。需要设计文档的是那些会影响其他人工作的变更。

**王磊**（让步但附条件）：

> 好，我可以接受一个折中方案。对于你说的那些"影响其他人"的变更，我同意先写设计文档。但我要加两个条件：
>
> 第一，设计文档的格式要极简——不超过一页，不要求写替代方案分析、不要求画架构图。核心就三部分：**做什么、接口是什么、对谁有影响**。如果一份设计文档需要写超过 30 分钟，说明它的粒度太大，应该拆任务。
>
> 第二，设计文档有有效期。合并代码后，设计文档的状态标记为"已实现"。如果后续代码改了但文档没更新，文档自动降级为"仅参考"。我们不追求文档跟代码永远一致——那不现实。

**陈思琪**（支持赵一凡但强化自己的诉求）：

> 一凡的方案我基本赞成。但我要再强调 Prompt 变更的特殊性。Prompt 不只是"影响其他人的代码变更"，它还是一种不可逆的质量风险。代码写错了跑不通，Prompt 写错了照样跑——只是结果不对。你可能在上线三天后才发现标签涌现的质量断崖式下跌，那时候已经处理了几千条数据了。
>
> 所以 Prompt 的审查标准应该比普通设计文档更严格：不只是审查文档，还要审查附带的样本测试结果。审查者不是看"设计合不合理"，而是看"输出质量有没有退化"。

**张晨曦**（明确底线）：

> 我再说一遍我的底线：**API 变更的 PR 必须让 CI 验证 OpenAPI Schema 是否跟代码一致**。FastAPI 能自动生成 Schema 不代表生成的结果一定对——Pydantic 模型的 `Optional` 字段、`exclude` 字段、`alias` 字段都可能让自动生成的 Schema 跟开发者预期不一致。
>
> 我建议在 CI 中加一个步骤：运行 FastAPI app，导出 OpenAPI JSON，跟仓库中的 Schema 文件做 diff。如果有差异，CI 报红。这样不管是后端忘了更新 Schema 还是代码跟 Schema 不一致，都能被捕获。

**周安**：

> 我从合规角度补充一点。安全相关的变更——涉及认证、授权、加密、API Key 处理的——不管规模大小，都必须有设计文档或至少有详细的 PR 描述说明安全影响。这不是为了增加流程，是为了日后审计有据可查。
>
> 另外，我支持张晨曦的 Schema 一致性检查方案。API 契约不一致不只是前端的问题，也是安全问题——比如一个字段本应加密传输但 Schema 里标记为 plaintext，这种不一致可能导致数据泄露。

### C2 决议

**设计文档分三级：必须写 / 建议写 / 不需要**

| 变更类型 | 文档要求 | 格式 | 审查要求 |
|---------|---------|------|---------|
| 架构级变更（新服务、服务间通信方式、shared 公共接口） | **必须** 先提 Design Doc PR | 极简一页纸（做什么 / 接口 / 影响范围） | 至少 2 人 Approval |
| 新增/修改 API 端点、数据模型 | **必须** 在 PR 描述中详细说明 | PR 描述模板（变更原因 / 接口定义 / 影响范围） | 1 人 Approval + 受影响方确认 |
| Prompt 模板变更 | **必须** 独立 PR + 附带测试结果 | PR 描述含变更原因 + 预期影响 + 至少 5 条样本前后对比 | AI 工程负责人（陈思琪）必须参与审查 |
| 安全相关变更 | **必须** 详细 PR 描述说明安全影响 | 使用安全审查模板 | 安全负责人（周安）必须参与审查 |
| Bug fix、重构、非接口变更 | 不需要设计文档 | 常规 PR 描述 | 1 人 Approval |

**API 契约同步机制**：

1. CI 流水线新增 OpenAPI Schema 一致性检查：自动导出 FastAPI 生成的 Schema 与仓库中的基准文件比对，不一致则 CI 报红
2. 后端 API 变更的 PR 必须 @mention 前端组成员，由前端评估适配工作量
3. 前端组有权 block API 契约不一致的 PR

**文档保鲜规则**：

1. 代码 PR 合并后，关联的 Design Doc 状态更新为"已实现"
2. PR 模板中包含 checklist 项：`[ ] 已更新相关设计文档（如适用）`
3. 不追求设计文档与代码永远一致——已实现的设计文档定位为"决策记录"而非"实时规格"

---

## 子议题 C3：代码审查标准

### 开场陈述

**周安**（主张：分级审查 + 安全模板）：

> 代码审查是合入 main 的最后一道关。我的方案是分级审查：
>
> 普通 PR：至少 1 个 Approval。涉及安全/认证/数据模型的 PR：至少 2 个 Approval，且安全负责人（就是我）必须是其中之一。
>
> 对于安全相关的 PR，我准备了一个审查清单模板，包括但不限于：输入是否经过验证和清洗？认证/授权检查是否完整？敏感数据是否加密处理？SQL 查询是否使用参数化？日志中是否避免记录敏感信息？
>
> 这个模板不是让每个审查者都逐项检查——只在 PR 标记了 `security` 标签时启用。大部分 PR 不需要走这个流程。

**王磊**（主张：审查要快、PR 要小）：

> 审查标准之前，先解决审查速度问题。审查慢是"审查瓶颈"的根源——不是标准太严，而是等待太久。
>
> 我的规则很简单：
> - 200 行以下的 PR：24 小时内完成审查
> - 200-500 行的 PR：48 小时内完成审查
> - 500 行以上的 PR：**不审查，打回要求拆分**
>
> 为什么是 500 行？研究表明，审查超过 400 行代码时，审查者的缺陷发现率断崖式下降。给你一个 1000 行的 PR，你看到第 300 行的时候大脑就开始走神了，后面 700 行基本就是"LGTM"。
>
> 另外，代码风格不应该出现在审查讨论中。ruff format + ruff check 在 pre-commit hook 里自动执行了，如果代码风格有问题根本提不上来 PR。审查者应该关注逻辑和设计，不是缩进和命名。

**赵一凡**（主张：重点审查架构一致性）：

> 我同意王磊说的审查速度问题。但我想强调的是审查应该看什么。
>
> 在我看来，代码审查最该关注的是架构一致性——导入规则有没有违反？分层有没有被穿透？配置有没有硬编码？shared 库的使用方式对不对？这些问题如果审查时不抓，等到代码量大了再想改就是大规模重构了。
>
> 具体来说，审查者应该检查：
> 1. **导入方向**：api → service → repository，不能反向。跨服务不能 import 内部模块。
> 2. **配置来源**：是否从 `Settings` 读取，有没有硬编码的 URL、端口、密钥。
> 3. **错误处理**：是否使用统一的异常体系，API 返回的错误格式是否一致。
> 4. **命名规范**：是否遵循项目约定（snake_case 包名、kebab-case URL、Conventional Commits）。

**张晨曦**（主张：前端 PR 有专属审查重点）：

> 前端代码的审查重点跟后端很不一样。后端看分层和导入规则，前端看的是：
>
> 1. **类型安全**：有没有 `any`？有没有 `as` 断言绕过类型检查？类型跟后端 Schema 是否一致？
> 2. **组件 API 设计**：props 命名是否清晰？是否有冗余 props（可以从上下文推导的不应该作为 props）？是否遵循 shadcn/ui 的组件模式？
> 3. **状态管理**：是否该用服务端状态（React Query）的地方错用了客户端状态（Zustand）？是否有不必要的全局状态？
> 4. **加载/错误/空状态**：每个数据展示页面是否都处理了 loading、error、empty 三种状态？
>
> 后端审查者看这些可能看不出问题。所以前端 PR 的审查者最好是前端开发者——目前就我一个，但李维做 CLI 也涉及一些 TypeScript，可以互相审查。

### 交锋辩论

**王磊**（对周安的双 Approval 提出质疑）：

> 周安，6 个人的团队要求 2 个 Approval 意味着三分之一的团队要看同一个 PR。算一下：你加上另一个人审查安全相关 PR，如果这个 PR 还涉及 API 变更需要前端确认，那就是三个人在看一个 PR——团队一半的人停下手头工作来审查。
>
> 我提一个替代方案：安全相关 PR 仍然只需要 1 个 Approval，但这 1 个必须是你。其他人可以选择性审查，但不作为 blocking 要求。这样保证安全视角不缺席，又不造成瓶颈。

**周安**（坚守立场但调整方案）：

> 王磊说的瓶颈问题确实存在。但 1 个 Approval 的风险是：如果我请假了或者忙不过来怎么办？安全审查不能因为一个人不在就停摆。
>
> 我接受折中方案：安全相关 PR 需要 1 个 Approval + 安全负责人确认。如果我 48 小时内没有审查，PR 可以由技术负责人（赵一凡）代为审查安全部分，但事后我必须补审。这样既保证安全审查不缺席，又不会造成长时间阻塞。

**赵一凡**（统合方案）：

> 我来试着统合一下。审查标准因领域不同确实应该有差异化，但不能搞出六套审查标准——那样太复杂了。我建议分两个维度：
>
> **维度一：PR 类型决定审查人数**
> - 普通 PR → 1 Approval
> - 安全/认证/加密相关 PR → 1 Approval + 安全负责人确认
> - shared 库公共接口变更 → 1 Approval + 技术负责人确认
>
> **维度二：领域标签决定审查重点**
> - `backend` 标签 → 审查重点是分层、导入规则、错误处理
> - `frontend` 标签 → 审查重点是类型安全、组件 API、状态管理
> - `ai-pipeline` 标签 → 审查重点是 Prompt 质量、输出守卫、测试覆盖
> - `data-pipeline` 标签 → 审查重点是输入校验、幂等性、编码处理
> - `security` 标签 → 触发安全审查清单
>
> 审查者不需要记住所有规则——按 PR 标签看对应的审查清单就行。

**陈思琪**（补充 AI 管线审查要求）：

> 一凡的框架我认同。AI 管线的 PR 我再补充一条审查要求：涉及 LLM 调用逻辑变更的 PR，审查者需要确认 mock 测试和真实测试都涵盖了。具体来说：
>
> - **必须有 mock 测试**：验证管线编排逻辑（JSON 解析、错误处理、状态流转）
> - **建议有真实测试结果**：PR 描述中附带至少 3 条真实 LLM 调用结果（不要求 CI 中自动运行）
>
> 这不是额外负担——开发 AI 管线的时候本来就会跑真实测试来调试，只是把结果贴到 PR 里而已。

**李维**：

> 我从数据工程角度加一条：数据管线的 PR 审查应该特别关注边界情况的测试覆盖。CSV 解析、编码检测这类代码，happy path 谁都会写，出问题的永远是异常格式——BOM 头、混合编码、Excel 的日期序列号、含逗号的引号字段。
>
> 审查者看到数据管线的 PR，第一件事应该问：测试用例里有没有"脏数据"的 case？如果没有，打回。

**王磊**（最后补充）：

> 提一个操作层面的建议。为了避免审查瓶颈，我建议建立一个简单的轮转制度：
>
> 每个 PR 随机指定一个主审查者（GitHub 的 auto-assign 功能）。主审查者负责在时限内完成审查。如果主审查者因为不熟悉该领域需要协助，可以拉相关领域负责人一起看，但不改变时限要求。
>
> 这样每个人都会审查不同领域的代码，长期来看有利于团队知识共享，避免"只有一个人看得懂这块代码"的风险。

### C3 决议

**代码审查标准：分级审查 + 领域审查清单 + 时限承诺**

#### 审查人数与角色

| PR 类型 | 所需 Approval | 特殊要求 |
|---------|-------------|---------|
| 普通 PR | 1 个 | 无 |
| 安全/认证/加密相关（`security` 标签） | 1 个 + 安全负责人确认 | 使用安全审查模板；若周安 48h 未审，赵一凡可代审（周安事后补审） |
| shared 库公共接口变更 | 1 个 + 技术负责人确认 | 赵一凡确认接口设计与架构一致性 |
| API 端点新增/变更 | 1 个 + 前端组知会 | PR 中 @mention 张晨曦评估前端影响 |
| Prompt 模板变更 | 1 个 + AI 工程负责人确认 | PR 附带 >= 5 条样本前后对比 |

#### 审查时限

| PR 规模 | 审查时限 | 说明 |
|---------|---------|------|
| < 200 行 | 24 小时 | 小型变更，快速流转 |
| 200-300 行 | 36 小时 | 中型变更，建议值 |
| 300-500 行 | 48 小时 | 大型变更，审查者可要求作者提供导读 |
| > 500 行 | **不审查，打回拆分** | 例外：自动生成代码（如迁移文件）不计入行数 |

#### 领域审查重点

| 领域标签 | 审查清单重点 |
|---------|-------------|
| `backend` | 分层是否正确（api → service → repository）；导入方向是否合规；配置是否从 Settings 读取；错误处理是否使用统一异常体系 |
| `frontend` | 零 `any` / 零 `as` 断言；组件 props 设计合理性；服务端状态 vs 客户端状态使用得当；loading/error/empty 三态处理 |
| `ai-pipeline` | Prompt 变更附带样本对比；mock 测试覆盖编排逻辑；守卫层校验完整性 |
| `data-pipeline` | 边界用例测试覆盖（脏数据、异常编码、特殊格式）；幂等性保证；输入校验完整性 |
| `security` | 安全审查模板逐项确认（输入校验、认证完整、加密处理、参数化查询、日志脱敏） |

#### 操作规范

1. **Auto-assign**：启用 GitHub 的 auto-assign 功能随机指定主审查者。主审查者可拉相关领域负责人协助审查
2. **代码风格免讨论**：ruff format + ruff check + ESLint + Prettier 在 pre-commit hook 中自动执行。代码风格问题不作为审查意见（CI 已保证）
3. **审查者导读请求权**：对于 300 行以上的 PR，审查者有权要求作者提供 PR 导读（关键变更说明 + 审查建议路径）
4. **知识共享轮转**：鼓励跨领域审查以促进知识共享，但不作为硬性要求。每个人每月至少审查 2 个非本领域 PR

---

## 总决议汇总

| 编号 | 决议项 | 具体规则 |
|------|--------|---------|
| C1-1 | 分支策略 | 改良版 GitHub Flow：main + 短命功能分支（建议 <= 3 天，硬限 5 天） |
| C1-2 | 分支命名 | `<type>/<issue-id>-<description>`，对齐 Conventional Commits |
| C1-3 | 同步机制 | 生命周期 > 1 天的分支每日 rebase main |
| C1-4 | 功能开关 | 暂不引入，保留未来引入可能 |
| C2-1 | 设计文档触发条件 | 架构级变更必须 Design Doc PR；API/数据模型变更必须详细 PR 描述 |
| C2-2 | Prompt 审查 | 独立 PR + 变更原因 + 影响评估 + >= 5 条样本对比 |
| C2-3 | API 契约同步 | CI 检查 OpenAPI Schema 一致性；后端变更必须知会前端 |
| C2-4 | 文档保鲜 | 代码合并后 Design Doc 标记"已实现"；PR 模板含文档更新 checklist |
| C3-1 | 审查人数 | 普通 1 个；安全/shared/Prompt 需专项负责人确认 |
| C3-2 | 审查时限 | < 200 行 24h；200-500 行 48h；> 500 行打回拆分 |
| C3-3 | 领域审查清单 | 5 类标签对应 5 套审查重点清单 |
| C3-4 | 操作规范 | Auto-assign 轮转 + 代码风格免讨论 + 跨领域审查鼓励 |

---

## 遗留事项

| 编号 | 事项 | 责任人 | 完成时间 |
|------|------|--------|---------|
| C-TODO-1 | 配置 GitHub main 分支保护规则（PR required、1 Approval、CI status check） | 周安 | 开发启动第 1 天 |
| C-TODO-2 | 编写 PR 模板（含设计文档 checklist、领域标签选择、安全审查模板） | 赵一凡 + 周安 | 开发启动第 2 天 |
| C-TODO-3 | 配置 CI 流水线中 OpenAPI Schema 一致性检查步骤 | 王磊 + 张晨曦 | M1 结束前 |
| C-TODO-4 | 建立 Prompt 审查流程模板（含样本对比格式） | 陈思琪 | 开发启动第 3 天 |
| C-TODO-5 | 配置 GitHub auto-assign 审查者轮转规则 | 周安 | 开发启动第 2 天 |

---

*本文档记录了议题组 C（工作流与协作）三个子议题的完整辩论过程和最终决议。核心基调是"轻流程、强自动化"——用工具（CI、pre-commit、auto-assign）替代人工流程约束，在保证代码质量和安全底线的前提下，最大化 6 人团队的迭代效率。*
