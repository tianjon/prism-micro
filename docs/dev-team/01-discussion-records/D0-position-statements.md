# D0：独立立场宣言

> 6 位开发团队成员针对 4 个核心开发议题的独立立场。每位成员在不知道他人观点的情况下独立撰写，消除锚定效应。

**日期**：开发启动前
**机制**：独立撰写，同时公开

---

## 议题总览

| 议题 | 核心问题 | 预期分歧 |
|------|---------|---------|
| **T1：代码组织与架构** | monorepo 包结构、导入规则、配置管理、DB 迁移策略 | 赵一凡（严格分层）vs 王磊（务实扁平） |
| **T2：API 与通信协议** | REST 约定、错误处理、服务间通信、认证传递 | 王磊（后端主导）vs 张晨曦（前端消费优先） |
| **T3：测试与质量保障** | 测试金字塔、LLM Mock 策略、CI/CD、代码审查 | 陈思琪（需真实 LLM 测试）vs 周安（隔离测试） |
| **T4：开发流程与协作** | Git 工作流、文档规范、任务管理、代码风格 | 周安（严格流程）vs 王磊（快速迭代） |

---

## T1：代码组织与架构

### 赵一凡（技术负责人）

**立场**：严格分层 + 强制导入规则

**一句话观点**：包结构是认知成本的物化——结构混乱意味着每个新人都要重新理解"什么放在哪"。

**关键论据**：
1. **三层包结构强制执行**：每个服务必须遵循 `api/ → service/ → repository/` 三层结构。`api` 层只做请求解析和响应封装，`service` 层包含业务逻辑，`repository` 层负责数据访问。跨层调用必须单向。
2. **导入规则白名单化**：通过 `ruff` 自定义规则或 `import-linter` 强制检查导入方向。例如：`llm_service.api` 可以导入 `llm_service.service`，但反向不允许；任何服务不得导入其他服务的内部模块。
3. **配置管理统一方案**：所有配置通过 `pydantic-settings` 从环境变量加载，每个服务有独立的 `Settings` 类继承 shared 的 `BaseSettings`。禁止在代码中硬编码配置值。
4. **DB 迁移独立性**：每个 Schema 独立 Alembic 环境（独立 `alembic.ini` + `migrations/`），各服务各管各的迁移历史，不共享迁移序列号。

**最大风险**：过度分层可能增加早期开发的模板代码量（boilerplate），降低小团队的开发效率。

---

### 陈思琪（AI 工程负责人）

**立场**：有条件支持分层，但 AI 管线需特殊处理

**一句话观点**：AI 管线是数据流而非请求-响应，不能用传统 Web 服务的分层套用。

**关键论据**：
1. **AI 管线目录独立**：voc-service 中的 AI 管线（Stage 1/2/3）应有独立的 `pipeline/` 目录，而非塞进通用的 `service/` 层。管线是 DAG 不是 RPC，结构应反映这一差异。
2. **Prompt 版本化管理**：Prompt 模板应集中管理在 `prompts/` 目录，支持版本号（如 `semantic_split_v1.jinja2`）。Prompt 变更等同于业务逻辑变更，应有独立的审查流程。
3. **模型评估数据与代码同仓**：测试用的 golden dataset（标注好的测试样本）应放在 `tests/fixtures/` 中，确保 AI 管线的输出质量有回归基准。

**最大风险**：过于特殊化 AI 管线的目录结构可能导致与其他服务的组织方式不一致，增加团队认知负担。

---

### 王磊（后端负责人）

**立场**：务实扁平 + 按需分层

**一句话观点**：6 个人的团队不需要 10 层抽象——先让代码能跑，遇到痛点再重构。

**关键论据**：
1. **两层就够**：早期只需要 `api/` + `core/`（业务逻辑 + 数据访问混合），不需要独立的 `repository` 层。SQLAlchemy 2.0 的 async session 已经足够抽象数据访问，再加一层 repository 纯属过度设计。
2. **配置直接用环境变量**：小项目用 `os.environ.get()` + 默认值就够了，`pydantic-settings` 引入了不必要的复杂度（嵌套验证、环境前缀等）。当配置项超过 20 个时再迁移。
3. **导入规则靠 PR 审查**：ruff 自定义规则的维护成本不低，小团队靠 PR review 约定导入规则比自动化工具更灵活。

**最大风险**：扁平结构在代码量增长后（>5000 行/服务）会导致 `core/` 目录膨胀，模块职责模糊。

---

### 周安（安全/DevOps 负责人）

**立场**：支持分层，强调安全边界

**一句话观点**：分层不只是代码组织，更是安全边界——API 层是输入验证的唯一入口。

**关键论据**：
1. **API 层必须独立**：`api/` 层承担所有输入验证、权限检查和请求清洗的职责。这是安全边界，不能与业务逻辑混合。
2. **敏感配置加密存储**：API Key、数据库密码等敏感配置不能明文存环境变量。至少使用 `.env` 文件 + gitignore，生产环境使用密钥管理服务。
3. **迁移脚本必须有回滚方案**：每个 Alembic 迁移必须同时实现 `upgrade()` 和 `downgrade()`。没有回滚能力的迁移不允许合并。

**最大风险**：安全要求过多可能让开发流程变得繁琐，降低早期迭代速度。

---

### 张晨曦（前端负责人）

**立场**：前端独立架构，关注类型契约

**一句话观点**：前端的代码组织取决于组件复用度，不取决于后端的服务结构。

**关键论据**：
1. **前端按功能域组织**：`src/features/{import,search,tags,admin}/`，每个功能域包含页面、组件、hooks、API 调用。不按技术层（components/hooks/pages）组织，而按业务域组织。
2. **API 层自动生成**：基于后端 OpenAPI Schema 自动生成 TypeScript 类型和 API 客户端（使用 `openapi-typescript-codegen` 或类似工具），不手写 API 调用。
3. **状态管理最小化**：Zustand 用于全局状态（认证、用户信息），页面级状态用 React Query / SWR 管理服务器状态，尽量减少客户端状态。

**最大风险**：OpenAPI 自动生成的类型可能与后端实际行为不一致（后端文档不完整时），导致运行时错误。

---

### 李维（数据工程负责人）

**立场**：数据管线与 Web 服务分离

**一句话观点**：爬虫和 ETL 不是 Web 请求处理——它们需要独立的运行环境和错误恢复机制。

**关键论据**：
1. **爬虫作为独立 Python 包**：爬虫脚本不应放在 voc-service 内部，应作为独立包（`apps/crawlers/` 或 `tools/crawlers/`），通过 CLI 触发并调用 voc-service API 导入数据。
2. **数据管线步骤可独立运行**：CSV 解析 → Schema 映射 → 数据清洗 → 入库，每个步骤应可独立运行和测试，输入输出通过标准化数据结构传递。
3. **CLI 命令按动词组织**：`prism import csv/excel`、`prism crawl dongchedi/weibo`、`prism search "query"`——动词前置，名词后置。

**最大风险**：爬虫独立部署可能增加运维复杂度，需要额外的进程管理。

---

## T2：API 与通信协议

### 赵一凡

**立场**：严格 API First + 契约冻结

**一句话观点**：API 是服务间的合同——一旦签署（冻结），不允许单方面撕毁（breaking change）。

**关键论据**：
1. **OpenAPI Spec 先于代码**：每个 API 先写 OpenAPI YAML，经前后端双方确认后再编码实现。FastAPI 自动生成的 Spec 作为验证基准，但设计阶段应手写 Spec。
2. **版本化策略**：Phase 1 使用 URL 前缀版本化（`/api/v1/`）。虽然当前不需要，但预留版本升级路径比后期改造成本低 10 倍。
3. **跨服务调用走 HTTP**：即使是后端服务间调用（如 voc-service 调用 llm-service 的 Embedding API），也必须走 HTTP，不允许直接 import 其他服务的内部模块。

**最大风险**：API First 在快速迭代阶段可能导致"文档追着代码跑"或"代码等着文档"的同步问题。

---

### 陈思琪

**立场**：AI 相关 API 需要特殊错误处理

**一句话观点**：LLM 调用失败不是普通的 500 错误——需要告诉调用方"是 LLM 的问题还是我们的问题"。

**关键论据**：
1. **LLM 错误码分层**：`LLM_PROVIDER_ERROR`（Provider 不可用）、`LLM_RESPONSE_INVALID`（LLM 返回了垃圾）、`LLM_GUARD_REJECTED`（守卫层拒绝了输出）——三类错误的处理策略完全不同。
2. **异步任务 API 模式**：AI 管线处理（导入 1000 条数据）不适合同步 API。应返回 `task_id` + 轮询状态 API（`GET /api/voc/import/{id}/status`），或使用 SSE 推送进度。
3. **降级标记必须透传**：如果 LLM 调用使用了降级模型，API 响应必须包含 `degraded: true` + `original_model` + `actual_model`，让调用方和用户知道这是降级结果。

**最大风险**：过于细粒度的错误码可能增加前端的处理复杂度。

---

### 王磊

**立场**：后端定义 API，前端消费

**一句话观点**：API 设计的最终裁判是"前端能不能一看就懂、一调就通"。

**关键论据**：
1. **RESTful 但不教条**：资源导向设计（`/api/voc/tags`、`/api/voc/voices/{id}`），但批量操作和搜索用 POST（`POST /api/voc/search`、`POST /api/voc/import`）。不为 REST 纯洁性牺牲 API 的可用性。
2. **统一分页格式**：`{ data: [...], pagination: { page, page_size, total }, meta: {...} }`。所有列表 API 统一使用此格式，前端只需一个通用分页组件。
3. **错误码用字符串而非数字**：`VALIDATION_ERROR`、`PROVIDER_UNAVAILABLE` 而非 `40001`、`50301`。字符串错误码自文档化，前端开发者不需要查表。

**最大风险**：过于宽松的 RESTful 约定可能导致 API 风格不一致（有的 GET 有的 POST）。

---

### 周安

**立场**：认证一致性 + 审计日志

**一句话观点**：每个 API 调用都必须知道"谁在调用"，这不是可选的。

**关键论据**：
1. **统一认证中间件**：所有 API（除注册/登录外）必须通过 shared 的认证中间件。中间件注入 `Principal` 对象（`type: human|agent, id: uuid`）到请求上下文。
2. **审计日志自动化**：通过 FastAPI middleware 自动记录所有写操作（POST/PUT/DELETE）的 principal、操作、参数、结果。不依赖各服务手动记录。
3. **API Key 有限权限**：Agent 使用的 API Key 应该有 scope 限制（如只能调用 LLM API，不能管理 Provider），不应与 JWT 等权限。

**最大风险**：统一审计日志可能产生大量数据，需要考虑日志存储和查询性能。

---

### 张晨曦

**立场**：前端消费优先 + 类型安全

**一句话观点**：API 返回的每一个字段都应该在 TypeScript 类型中有对应——没有 `any`，没有可选的必填字段。

**关键论据**：
1. **响应字段不可为 `null` 除非有明确语义**：`{ data: null }` 不等于 `{}`。如果字段"没有值"，要么不返回该字段，要么用空数组/空对象。`null` 只用于"值明确不存在"的语义（如 `parent_tag_id: null` 表示无父标签）。
2. **时间字段统一 ISO 8601**：所有时间戳用 `2026-02-12T10:00:00Z` 格式，不用 Unix 时间戳。前端需要直接展示时间，不想每次都做转换。
3. **批量操作返回逐条结果**：`POST /api/voc/import` 的响应应包含每条数据的处理状态（成功/失败/跳过），而非只返回总数。前端需要展示详细导入结果。

**最大风险**：过于严格的类型要求可能在 API 快速迭代阶段造成频繁的类型更新。

---

### 李维

**立场**：CLI 输入输出标准化

**一句话观点**：CLI 是 Agent 的工具接口——输出必须机器可解析，不能只给人看。

**关键论据**：
1. **双模式输出**：CLI 默认输出人类友好格式（表格、进度条），加 `--json` 标志输出机器可解析的 JSON。Agent 调用时固定使用 `--json`。
2. **退出码有语义**：`0` = 成功，`1` = 参数错误，`2` = 认证失败，`3` = 服务不可达，`4` = 部分成功（如 100 条导入中 5 条失败）。
3. **爬虫 API 与直接脚本两种触发方式**：CLI `prism crawl` 调用后端 API 触发（异步），也支持 `--direct` 模式直接运行爬虫脚本（同步）。Phase 1 优先实现直接模式。

**最大风险**：双模式输出的维护成本较高，可能在一种模式上投入不足。

---

## T3：测试与质量保障

### 赵一凡

**立场**：测试金字塔 + 架构测试

**一句话观点**：最有价值的测试不是测业务逻辑的单元测试，而是测架构约束的自动化检查。

**关键论据**：
1. **架构测试**：用 `import-linter` 或自定义脚本测试导入规则——如果 `llm_service.api` 导入了 `voc_service` 的任何模块，CI 直接报红。这比 100 个单元测试更有价值。
2. **测试金字塔比例**：单元测试 70% + 集成测试 25% + E2E 测试 5%。集成测试使用 TestContainers 启动真实 PostgreSQL，不 Mock 数据库。
3. **CI 门禁标准**：`ruff check` 零告警 + `pyright` 零错误 + `pytest` 全通过 + 覆盖率 > 60%。任一不满足不允许合并。

**最大风险**：TestContainers 启动真实数据库会显著增加 CI 时间（每次 +30-60s）。

---

### 陈思琪

**立场**：LLM 测试需要真实调用层

**一句话观点**：Mock LLM 只能测管线编排逻辑，不能测 AI 输出质量——两者都需要。

**关键论据**：
1. **三层测试策略**：
   - **快速测试（CI 必跑）**：Mock LLM 响应，测试管线编排逻辑（JSON 解析、错误处理、状态流转）
   - **回归测试（每日/PR 可选）**：使用 Golden Dataset（标注好的 10-20 条样本），调用真实 LLM，验证输出质量不退化
   - **基准测试（里程碑前）**：大规模测试（100+ 条），评估标注一致性、标签涌现质量
2. **Prompt 变更触发回归**：任何 Prompt 模板的修改必须触发 LLM 回归测试，不能只跑单元测试。
3. **Golden Dataset 版本化**：测试数据集放在 `tests/fixtures/golden/` 中，与代码同仓管理，变更需审查。

**最大风险**：真实 LLM 测试有成本（API 费用）、不确定性（输出可能变化）和速度问题（每次调用 1-5 秒）。

---

### 王磊

**立场**：测试要务实——测关键路径，不测一切

**一句话观点**：测试 ROI 最高的是 API 集成测试，而不是每个私有方法的单元测试。

**关键论据**：
1. **API 测试优先**：用 `httpx.AsyncClient` + `pytest-asyncio` 测试 FastAPI 端点。一个 API 测试覆盖了路由 → 业务逻辑 → 数据访问全链路。
2. **不测私有方法**：如果一个方法不是公共 API 的一部分，不为它写专门的单元测试。通过 API 测试间接覆盖。
3. **Mock 策略要简单**：LLM 调用统一 Mock 为固定响应，不需要复杂的 Mock 逻辑。真实 LLM 测试留给手动回归。

**最大风险**：只测 API 层可能遗漏边界条件（如 JSON 解析异常、类型转换错误）。

---

### 周安

**立场**：隔离测试 + 安全测试

**一句话观点**：CI 流水线不应依赖任何外部服务——包括 LLM Provider、外部 API、甚至网络。

**关键论据**：
1. **完全隔离的 CI**：CI 环境中所有外部依赖（LLM、Redis、外部 API）全部 Mock。真实数据库用 `testcontainers` 或 `sqlite` 替代。CI 不能因为某个外部服务宕机而失败。
2. **安全测试自动化**：输入验证测试（SQL 注入、XSS、超长输入）、认证测试（无 token、过期 token、伪造 token）作为标准测试套件。
3. **依赖漏洞扫描**：CI 中集成 `pip-audit`（Python）和 `npm audit`（前端），有高危漏洞直接阻断。

**最大风险**：完全隔离测试可能无法发现真实环境中的集成问题（如 LLM Provider API 变更）。

---

### 张晨曦

**立场**：前端组件测试 + 视觉回归

**一句话观点**：前端测试的核心是"用户看到的东西对不对"，而不是"React 组件内部状态对不对"。

**关键论据**：
1. **组件测试用 Testing Library**：测试用户行为（点击、输入、提交），不测组件内部实现。`screen.getByRole('button')` 而不是 `wrapper.find('.btn-primary')`。
2. **API Mock 用 MSW**：Mock Service Worker 在网络层拦截 API 请求，前端代码无感知。测试数据集中管理在 `src/mocks/handlers.ts`。
3. **E2E 测试只覆盖关键流程**：Playwright 测试登录 → 数据导入 → 查看标签 → 语义搜索 → 提交反馈，5 个关键用户路径。不全面覆盖。

**最大风险**：视觉回归测试的基准图像维护成本高，屏幕尺寸和渲染差异可能导致误报。

---

### 李维

**立场**：数据管线测试要有真实数据

**一句话观点**：数据处理代码的测试必须使用真实格式的样本数据——Faker 生成的假数据覆盖不到编码问题。

**关键论据**：
1. **真实样本数据**：`tests/fixtures/` 中保存真实格式的 CSV/Excel 样本（脱敏后），包括 UTF-8、GBK、含 BOM、含空行、含特殊字符等边界情况。
2. **爬虫测试用录制回放**：使用 `responses` 或 `respx` 录制真实的 HTTP 响应，离线回放测试。不在 CI 中真实访问懂车帝/微博。
3. **幂等性测试**：导入管线的每个步骤必须有幂等性测试——同一份数据导入两次，第二次应全部跳过（去重生效）。

**最大风险**：真实样本数据可能包含敏感信息，需要严格脱敏。

---

## T4：开发流程与协作

### 赵一凡

**立场**：主干开发 + 功能开关

**一句话观点**：多长期分支 = 合并地狱——小团队应该在主干上开发，用功能开关控制未完成特性。

**关键论据**：
1. **主干开发（Trunk-Based）**：`main` 是唯一的长期分支。所有开发在短生命周期的功能分支上进行（< 2 天），频繁合并回 main。
2. **功能开关而非功能分支**：未完成的特性通过环境变量开关隐藏（如 `FEATURE_VOC_IMPORT=false`），而非长期在分支上开发。
3. **设计文档先于代码**：重要变更（新 API、新数据模型、架构调整）必须先提 Design Doc PR，经至少 2 人审查后再开始编码。

**最大风险**：功能开关增加了运行时分支复杂度，如果管理不善反而比分支更混乱。

---

### 陈思琪

**立场**：Prompt 变更需要独立审查流程

**一句话观点**：Prompt 的变更影响远大于代码变更——一个 Prompt 词的调整可能影响全量 AI 输出。

**关键论据**：
1. **Prompt PR 独立**：Prompt 模板变更应作为独立 PR，不与代码变更混在一起。PR 描述中必须包含"变更原因"和"预期影响评估"。
2. **Prompt 变更附带测试结果**：Prompt PR 必须附带至少 5 条样本数据的前后对比结果（手动运行回归测试）。
3. **版本号管理**：Prompt 模板使用语义版本号（v1, v2, v3），旧版本不删除，保留回退能力。

**最大风险**：独立的 Prompt 审查流程可能拖慢迭代速度——AI 管线的调优依赖频繁的 Prompt 微调。

---

### 王磊

**立场**：快速迭代 + 最小化流程

**一句话观点**：6 个人的团队不需要 JIRA——GitHub Issues + PR 就是最好的任务管理。

**关键论据**：
1. **GitHub Issues 作为任务管理**：每个功能/Bug 一个 Issue，PR 关联 Issue。不需要额外的项目管理工具。
2. **PR 审查要快**：< 200 行的 PR 24 小时内审查完毕。超过 500 行的 PR 应被拆分。
3. **代码风格自动化**：ruff format + ruff check 在 pre-commit hook 中自动执行。代码风格不应成为 PR review 的讨论话题。

**最大风险**：GitHub Issues 在复杂项目中的跟踪能力有限，可能丢失跨 Issue 的依赖关系。

---

### 周安

**立场**：严格的代码审查 + 合规记录

**一句话观点**：每一行合并到 main 的代码都应有第二个人看过——不是建议，是要求。

**关键论据**：
1. **强制 PR 审查**：`main` 分支开启保护规则，至少 1 个 Approval 才能合并。涉及安全/认证/数据模型的 PR 需要 2 个 Approval。
2. **Commit Message 规范**：使用 Conventional Commits（`feat:`, `fix:`, `refactor:`, `docs:`），便于自动生成 changelog。
3. **安全变更审查清单**：涉及认证、授权、加密、API Key 处理的 PR 必须使用安全审查模板，逐项确认安全约束满足。

**最大风险**：双人审查要求在 6 人团队中可能造成审查瓶颈，阻塞开发进度。

---

### 张晨曦

**立场**：前后端契约驱动开发

**一句话观点**：API 契约确定后，前后端应该可以完全并行开发——不等对方。

**关键论据**：
1. **契约先行**：API 端点定义完成后，前端立即开始开发（使用 MSW Mock 数据），不等后端实现完成。
2. **TypeScript 严格模式**：`tsconfig.json` 开启 `strict: true`，ESLint 禁用 `any` 类型。类型错误不是 warning，是 error。
3. **组件文档化**：核心业务组件需要 Storybook 展示（不是全部，只是核心的）——数据导入面板、标签列表、搜索结果卡片。

**最大风险**：契约先行要求后端在实现前就冻结 API 设计，可能限制后端根据实现调整 API。

---

### 李维

**立场**：数据质量检查前置

**一句话观点**：脏数据进系统比没有数据更危险——导入管线的第一道关不是解析，是校验。

**关键论据**：
1. **导入前校验**：文件上传后先做格式检查（编码检测、行数限制、必填列校验），校验失败直接拒绝，不进入后续管线。
2. **数据质量报告**：每次导入完成后生成质量报告（空值率、重复率、异常值数量），存入 IngestionBatch 的 metadata。
3. **爬虫数据标准化**：爬虫输出统一为 JSONL 格式（每行一个 JSON 对象），字段名固定（content、author、published_at、source_url），不允许各爬虫自定义 Schema。

**最大风险**：过于严格的数据校验可能在真实场景中拒绝大量"有瑕疵但有价值"的数据。

---

*本文档记录了 6 位开发团队成员对 4 个核心开发议题的独立立场宣言。各位成员的立场反映了其专业背景和职责视角的差异，这些分歧将在 D1 聚焦辩论中深入讨论。*
